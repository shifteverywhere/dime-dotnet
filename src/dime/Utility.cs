//
//  Utility.cs
//  Di:ME - Digital Identity Message Envelope
//  A secure and compact messaging format for assertion and practical use of digital identities
//
//  Released under the MIT licence, see LICENSE for more information.
//  Copyright Â© 2022 Shift Everywhere AB. All rights reserved.
//
using System;
using System.Text;
using System.Security.Cryptography;
using System.Xml;

namespace ShiftEverywhere.DiME
{
    public static class Utility
    {

        private static readonly RNGCryptoServiceProvider RngCsp = new();
        
        /// <summary>Will generates random bytes.</summary>
        /// <param name="size">The number of bytes to generate.</param>
        /// <returns>A byte array with the generated bytes.</returns>
        public static byte[] RandomBytes(int size)
        {
            var value = new byte[size];
            RngCsp.GetBytes(value);
            return value;
        }

        public static string ToHex(byte[] bytes)
        {
            var hex = new StringBuilder(bytes.Length * 2);
            foreach (var b in bytes)
                hex.Append($"{b:x2}");
            return hex.ToString();
        }

        public static string ToBase64(byte[] bytes)
        {
            return Convert.ToBase64String(bytes).Trim('=');
        }

        public static string ToBase64(string str)
        {
            return ToBase64(Encoding.UTF8.GetBytes(str));
        }

        public static byte[] FromBase64(String base64)
        {
            var str = base64;
            str = str.Replace('_', '/').Replace('-', '+');
            var padding = base64.Length % 4;
            if (padding > 1)
            {
                str += padding == 2 ? "==" : "=";
            }
            return Convert.FromBase64String(str);
        }

        public static byte[] Combine(byte[] first, byte[] second)   
        {
            var bytes = new byte[first.Length + second.Length];
            Buffer.BlockCopy(first, 0, bytes, 0, first.Length);
            Buffer.BlockCopy(second, 0, bytes, first.Length, second.Length);
            return bytes;
        }

        public static byte[] SubArray(byte[] array, int start, int length)
		{
			var bytes = new byte[length];
			Buffer.BlockCopy(array, start, bytes, 0, length);
			return bytes;
		}

		public static byte[] SubArray(byte[] array, int start)
		{
			return SubArray(array, start, array.Length - start);
		}

        public static byte[] Prefix(byte prefix, byte[] array)
        {
            var bytes = new byte[array.Length + 1];
            array.CopyTo(bytes, 1);
            bytes[0] = prefix;
            return bytes;
        }

        public static string ToTimestamp(DateTime date)
        {
            return XmlConvert.ToString(date, XmlDateTimeSerializationMode.Utc);
        }

        public static DateTime FromTimestamp(string timestamp)  
        {
            return DateTime.Parse(timestamp).ToUniversalTime();
        } 

    }

}
